# Express & SQL w. PG Show & Create

## Adding a Database to our Express App

## Rebuild Bookmarks

## Getting Started

- Get your express server running
- Make sure Postgres is running
- In the browse,r go to the index route and check that it works

## Show

**IMPORTANT:** One thing that will be different with your builds is that instead of using the array position, we will use each item's unique `id` generated by Postgres.

For example, looking at the data, we inserted `Apartment Therapy` should have an `id` of `2`.

![](./assets/id-not-array-index.png)

If we were to access it by array position, it would be at array position `1`. We used array positions earlier for simplicity. However, there is never a guarantee that an item will be in a particular order/array position, and it can change. So using the `id` now that we have a database is critical.

Create an async arrow function and be sure to include it in `module.exports`

```js
// queries/bookmarks.js
// ONE Bookmark
const getBookmark = async () => {};

module.exports = {
  getAllBookmarks,
  getBookmark,
};
```

We will get the `id` from the `req.params` in the show route (in bookmarkController - see below).

We will use `db.oneOrNone` because we expect one row to be returned.

We are passing two arguments, one is the SQL query, and the second is the value coming in from the request. In this case, we want to show the `id` of the bookmark.

We represent that `id` in the SQL query using `$1` rather than inserting the value, as we might if it were a JavaScript string interpolation.

The reason is safety.

[Bonus Video on SQL Injection](https://www.google.com/search?q=SQL+injection+computerphile&client=safari&rls=en&ei=os7UYNnYDfOv5NoPicmJwA4&oq=SQL+injection+computerphile&gs_lcp=Cgdnd3Mtd2l6EAMyAggAMgYIABAWEB46BwgAEEcQsAM6BAgAEEM6BwgAELEDEEM6BQgAELEDOgQIABANSgQIQRgAUIcyWLNEYO5FaAJwAngAgAFriAGfCJIBBDE1LjGYAQCgAQGqAQdnd3Mtd2l6yAEIwAEB&sclient=gws-wiz&ved=0ahUKEwjZsevv8rDxAhXzF1kFHYlkAugQ4dUDCA0&uact=5)

**BONUS Cartoon**
![](https://imgs.xkcd.com/comics/exploits_of_a_mom.png)

```js
const getBookmark = async (id) => {
  try {
    const oneBookmark = await db.one("SELECT * FROM bookmarks WHERE id=$1", id);
    return oneBookmark;
  } catch (error) {
    return error;
  }
};
```

**NOTE**: You may also pass in arguments to your SQL query using an object with named keys like so:

```js
// DEMO do not code
await db.one("SELECT * FROM bookmarks WHERE id=$[id]", {
  id: id,
});
```

Knowing this alternate syntax can be helpful as you look at other coding examples. When you work on a project, stick with one syntax type for readability and maintainability.

Import the function

```js
// controllers/bookmarkController.js
const { getAllBookmarks, getBookmark } = require("../queries/bookmarks");
```

Create the show route and test it in the browser/Postman.

```js
// SHOW
bookmarks.get("/:id", async (req, res) => {
  const { id } = req.params;
  res.json({ id });
});
```

Add in the query and add some logic for the 404

```js
// SHOW
bookmarks.get("/:id", async (req, res) => {
  const { id } = req.params;
  const bookmark = await getBookmark(id);
  if (bookmark) {
    res.json(bookmark);
  } else {
    res.status(404).json({ error: "not found" });
  }
});
```

## Create

Create an async arrow function and be sure to include it in `module.exports`

```js
// queries/bookmarks.js
const createBookmark = async (bookmark) => {
  try {
  } catch (error) {
    throw error;
  }
};

module.exports = {
  getAllBookmarks,
  createBookmark,
  getBookmark,
};
```

Inserting into the database requires two arguments.

We'll use `db.one()` because we expect one row to be returned. When we return `one`, we get an object. If we return `any` or `many`, we get back an array. This will be important as to how we handle accessing our data in the front end.

We are passing two arguments to `db.one`. The first is the SQL query, where the values are represented as `$1`, `$2` etc. In the second, we are passing an array for each value.

| SQL Value | SQL Column  |      Array Value       | Array Index |
| :-------: | :---------: | :--------------------: | :---------: |
|    $1     |    name     |    `bookmark.name`     |      0      |
|    $2     |     url     |     `bookmark.url`     |      1      |
|    $3     | is_favorite | `bookmark.is_favorite` |      2      |

Set up our basic statement:

```js
// CREATE
const createBookmark = async (bookmark) => {
  try {
    const newBookmark = await db.one(
      "INSERT INTO bookmarks (name, url, category, is_favorite) VALUES($1, $2, $3, $4) RETURNING *",
      [bookmark.name, bookmark.url, bookmark.category, bookmark.is_favorite]
    );
    return newBookmark;
  } catch (error) {
    return error;
  }
};
```

Import the function

```js
// controllers/bookmarkController.js
const {
  getAllBookmarks,
  getBookmark,
  createBookmark,
} = require("../queries/bookmarks");
```

Create the show route and test it with Postman.

```js
// CREATE
bookmarks.post("/", async (req, res) => {
  try {
    const bookmark = await createBookmark(req.body);
    res.json(bookmark);
  } catch (error) {
    res.status(400).json({ error: error });
  }
});
```

Example Bookmark:

```js
{
 "name":"AV Club",
 "url": "https://www.avclub.com",
 "is_favorite": "false"
}
```

Remember to have:

- Route `POST` `/bookmarks`
- Select: `body`, `raw`, `JSON` from the options
- Valid JSON

![](./assets/postman-create.png)

## Error Handling/Validating input

Our users can make a bunch of mistakes.

Forgetting a name:

```js
{
 "url": "https://www.avclub.com",
 "is_favorite": "false"
}
```

We get a hard-to-read error. We want to check if there is a name and then send back an appropriate status code and a more human-readable error.

We can add this logic to our route, but then our route is validating and sending a response. It would be better to write a separate function that validates it. It also would make sense to put it in its file for better organization.

- `mkdir validations`
- `touch validations/checkBookmarks.js`

```js
// validations/checkBookmarks.js
const checkName = (req, res, next) => {
  console.log("checking name...");
};

module.exports = { checkName };
```

```js
// controller/bookmarksController.js
const { checkName } = require("../validations/checkBookmarks.js");
```

Add this function as middleware for the create route.

```js
// CREATE
bookmarks.post("/", checkName, async (req, res) => {
```

This request will hang because we are not sending a response.

```js
const checkName = (req, res, next) => {
  if (req.body.name) {
    console.log("name is ok");
  } else {
    res.status(400).json({ error: "Name is required" });
  }
};
```

OK, we get our error message. But how do we return to our route if we enter a name now?

We use the `next` function.

```js
const checkName = (req, res, next) => {
  if (req.body.name) {
    return next();
  } else {
    res.status(400).json({ error: "Name is required" });
  }
};
```

Let's try again:

Error:

```js
{
 "url": "https://www.avclub.com",
 "is_favorite": "false"
}
```

OK:

```js
{
 "name": "Apple",
 "url": "https://www.apple.com",
 "is_favorite": "true"
}
```

#### Another User Error

We can end up where the user/front-end app does not give a Boolean value.

```js
{
 "name":"Ikea",
 "url": "https://www.ikea.com",
 "is_favorite": "Maybe"
}
```

PostgreSQL is strict. It will not accept `maybe`.

Let's try to create this new bookmark. We get another Postgres error that we can read and understand, but we'd like to send back a status and error message again.

**validations/checkBookmarks/js**

```js
const checkBoolean = (req, res, next) => {
  if (req.body.is_favorite) {
    next();
  } else {
    res.status(400).json({ error: "is_favorite must be a boolean value" });
  }
};

module.exports = { checkBoolean, checkName };
```

Don't forget to add this to the `bookmarkController.js`.

```js
const { checkBoolean, checkName } = require("../validations/checkBookmarks.js");


// Further down
bookmarks.post("/", checkBoolean, checkName, async (req, res) => {
```

Hmmm, not quite right. How can we check if the `req.body.is_favorite` value is a boolean value?

If you don't know, go ahead and google it.

<details><summary>Possible Solution</summary>

```js
const checkBoolean = (req, res, next) => {
  const { is_favorite } = req.body;
  // account if string or undefined
  // the value false will evaluate to false
  // therefore check if typeof is boolean as well
  if (
    is_favorite == "true" ||
    is_favorite == "false" ||
    is_favorite == undefined ||
    typeof is_favorite == "boolean"
  ) {
    next();
  } else {
    res.status(400).json({ error: "is_favorite must be a boolean value" });
  }
};
```

</details>

## Save it

- `git add -A`
- `git commit -m 'show and create complete'`.

## Reference

[See the build here](https://github.com/pursuit-curriculum-resources/express-sql-seed-read-demo/tree/show-create)
