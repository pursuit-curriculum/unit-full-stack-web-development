# Express & SQL w. PG Show & Create

## Learning Objectives,

By the end of this lesson, you should be able to:

- Create a model file connected to a database that can return all data from a table, a specific row from a table, or a new row in a table.
- Handle asynchronous errors within a controller file and respond from the server appropriately.
- Use asynchronous code within a controller file to respond to client requests with persisted data.

## Getting Started

This is a continuation of the previous lesson.

- Get your express server running
- Make sure Postgres is running
- In the browse,r go to the index route and check that it works

## Show

> **Note**: One thing that will be different with your builds is that instead of using the array position, we will use each item's unique `id` generated by Postgres.

If we were to access it by array position, it would be at array position `1`. You used array positions earlier for simplicity. However, there is never a guarantee that an item will be in a particular order/array position, and it can change. So using the `id` now that we have a database is critical.

Create an async arrow function and be sure to include it in `module.exports`

```js
// queries/colors.js

// ONE Color
const getColor = async () => {};

module.exports = {
  getAllColors,
  getColor,
};
```

You will get the `id` from the `req.params` in the show route (in colorsController - see below).

You will use `db.one()` because we expect one row to be returned.

You are passing two arguments to `db.one()`, one is the SQL query, and the second is the value coming in from the request. In this case, it is the `id` of the color we want to show.

It may be tempting to write the SQL query using a JavaScript template literal like this:

```javascript
`SELECT * FROM colors WHERE id=${id};`;
```

However, this is unsafe. Instead in the SQL string will look like this (which uses `$1` as a placeholder for a variable):

```js
"SELECT * FROM colors WHERE id=$1";
```

And a second argument in the `db.one()` function will be used to pass in the data.

```js
const oneColor = await db.one("SELECT * FROM colors WHERE id=$1", id);
```

The reason for this extra step is to prevent SQL injection attacks by hackers. [Bonus Video on SQL Injection](https://www.google.com/search?q=SQL+injection+computerphile&client=safari&rls=en&ei=os7UYNnYDfOv5NoPicmJwA4&oq=SQL+injection+computerphile&gs_lcp=Cgdnd3Mtd2l6EAMyAggAMgYIABAWEB46BwgAEEcQsAM6BAgAEEM6BwgAELEDEEM6BQgAELEDOgQIABANSgQIQRgAUIcyWLNEYO5FaAJwAngAgAFriAGfCJIBBDE1LjGYAQCgAQGqAQdnd3Mtd2l6yAEIwAEB&sclient=gws-wiz&ved=0ahUKEwjZsevv8rDxAhXzF1kFHYlkAugQ4dUDCA0&uact=5).

**BONUS Cartoon**
![](https://imgs.xkcd.com/comics/exploits_of_a_mom.png)

```js
const getColor = async (id) => {
  try {
    const oneColor = await db.one("SELECT * FROM colors WHERE id=$1", id);
    return oneColor;
  } catch (error) {
    return error;
  }
};
```

**NOTE**: You may also pass in arguments to your SQL query using an object with named keys like so:

```js
await db.one("SELECT * FROM colors WHERE id=$[id]", {
  id: id,
});
```

Knowing this alternate syntax can be helpful as you look at other coding examples. When you work on a project, stick with one type of syntax for readability and maintainability.

Import the function to your controller.

```js
// controllers/colorsController.js
const { getAllColors, getColor } = require("../queries/color");
```

Create the show route and test it in the browser/Postman

```js
// controllers/colorsController.js
// SHOW
colors.get("/:id", async (req, res) => {
  const { id } = req.params;
  res.json({ id });
});
```

Add in the query and add some logic for the 404

```js
// controllers/colorsController.js
// SHOW
colors.get("/:id", async (req, res) => {
  const { id } = req.params;
  const color = await getColor(id);
  if (color) {
    res.json(color);
  } else {
    res.status(404).json({ error: "not found" });
  }
});
```

## Create

Create an async arrow function and be sure to include it in `module.exports`

```js
// queries/colors.js
const createColor = async (color) => {
  try {
  } catch (error) {
    throw error;
  }
};

module.exports = {
  getAllColors,
  createColor,
  getColor,
};
```

Inserting into the database requires two arguments.

We'll use `db.one()` because we expect one row to be returned. When we return `one`, we get an object. If we return `any` or `many`, we get back an array. This will be important as to how we handle accessing our data in the front end.

You are passing two arguments to `db.one`. The first is the SQL query, where the values are represented as `$1`, `$2` etc. In the second, we are passing an array for each value.

| SQL Value | SQL Column  |     Array Value     | Array Index |
| :-------: | :---------: | :-----------------: | :---------: |
|    $1     |    name     |    `color.name`     |      0      |
|    $2     | is_favorite | `color.is_favorite` |      1      |

Set up our basic statement:

```js
// queries/color.js
// CREATE
const createColor = async (color) => {
  try {
    const newColor = await db.one(
      "INSERT INTO colors (name, is_favorite) VALUES($1, $2) RETURNING *",
      [color.name, color.is_favorite]
    );
    return newColor;
  } catch (error) {
    return error;
  }
};
```

Import the function

```js
// controllers/colorsController.js
const { getAllColors, getColor, createColor } = require("../queries/color");
```

Create the show route and test it with Postman

```js
// CREATE
colors.post("/", async (req, res) => {
  const color = await createColor(req.body);
  res.json(color);
});
```

Example Color:

```js
{
 "name":"fuchsia",
 "is_favorite": "false"
}
```

Remember to have:

- Route `POST` `/colors`
- Select: `body`, `raw`, `JSON` from the options
- Valid JSON

## Error Handling/Validating input

Our users can make a bunch of mistakes.

Forgetting a name:

```js
{
 "is_favorite": "false"
}
```

You get a hard-to-read error. You want to check if there is a name and then send back an appropriate status code and a more human-readable error.

You can add this logic to our route, but then our route is validating and sending a response. It would be better to write a separate function that validates it. It also would make sense to put it in its own file for better organization.

- `mkdir validations`
- `touch validations/checkColors.js`

```js
// validations/checkColors.js
const checkName = (req, res, next) => {
  console.log("checking name...");
};

module.exports = { checkName };
```

```js
//controller/colorsController.js
const { checkName } = require("../validations/checkColors.js");
```

Add this function as middleware for the create route.

```js
// CREATE
colors.post("/", checkName, async (req, res) => {
```

This request will hang because we are not sending a response.

```js
const checkName = (req, res, next) => {
  if (req.body.name) {
    console.log("name is ok");
  } else {
    res.status(400).json({ error: "Name is required" });
  }
};
```

Ok, we get our error message. But if we enter a name now, how do we return to our route?

You use the `next` function.

```js
const checkName = (req, res, next) => {
  if (req.body.name) {
    return next();
  } else {
    res.status(400).json({ error: "Name is required" });
  }
};
```

Let's try again

```js
{
 "name": "cornflowerblue",
 "is_favorite": "true"
}
```

#### Another User Error

You can end up where the user/front-end app does not give a Boolean value.

```js
{
 "name":"honeydew",
 "is_favorite": "Maybe"
}
```

PostgreSQL is strict. It will not accept `maybe`.

Let's try to create this new color. You get another Postgres error that we can read and understand, but we'd like to send back a status and error message again.

```js
// validations/checkColors/js
const checkBoolean = (req, res, next) => {
  if (req.body.is_favorite) {
    next();
  } else {
    res.status(400).json({ error: "is_favorite must be a boolean value" });
  }
};

module.exports = { checkBoolean, checkName };
```

Don't forget to add this to the `colorsController.js`.

```js
const { checkBoolean, checkName } = require("../validations/checkColors.js");


// Further down...
colors.post("/", checkBoolean, checkName, async (req, res) => {
```

Hmmm, not quite right. Our `if` statement is checking if the value is truthy, not if it is an actual boolean value. How can we check if the value of `req.body.is_favorite` is a boolean value?

If you don't know, go ahead and google it.

<details><summary>Possible Solution</summary>

```js
const checkBoolean = (req, res, next) => {
  const { is_favorite } = req.body;
  if (
    is_favorite == "true" ||
    is_favorite == "false" ||
    is_favorite == undefined
  ) {
    next();
  } else {
    res.status(400).json({ error: "is_favorite must be a boolean value" });
  }
};
```

</details>

## Save it

- `git add -A`
- `git commit -m 'show and create complete'`.

## Reference

[See completed build](https://github.com/pursuit-curriculum-resources/pre-reading-express-sql-seed-read/tree/show-create)
